# コーディング規約

## 1. はじめに
本ドキュメントは、Chrome拡張機能「Super Mouse Gesture」におけるコーディング規約を定める。
コードの品質、可読性、保守性を向上させ、プロジェクト全体で一貫性のあるコードベースを維持することを目的とする。

## 2. TypeScript全般

### 2.1. 型安全性
- **Strict型付け**: TypeScriptのStrictモードを有効にし、型安全性を確保する。
- **`any`型の使用禁止**: `any`型は原則として使用しない。型が不明な場合は`unknown`を使用する。
- **型推論の活用**: 明示的な型指定が不要な場合は、型推論を活用してコードを簡潔に保つ。
- **型アサーションの慎重な使用**: `as`による型アサーションは、型チェックを回避するため、実行時エラーの原因となる可能性がある。そのため、可能な限り型ガードを使用する。

### 2.2. クラスの使用方針

#### 2.2.1. 基本方針
**TypeScriptにおけるクラスの使用は、必要な場合のみに限定する。**
特にユーティリティ関数やシングルトンパターンの実装においては、関数ベースのアプローチを優先する。

#### 2.2.2. クラスを使用すべきケース
以下のような場合のみクラスの使用を検討する：
- **インスタンスごとに独立した状態を持つ必要がある場合**
  - 例: 複数の独立したインスタンスが必要な状態管理オブジェクト
- **継承による機能拡張が明確に必要とされる場合**
  - 例: 基底クラスから複数の派生クラスを作成する明確な設計
- **オブジェクト指向的な設計が問題領域に適している場合**
  - 例: ドメインモデルの表現など

#### 2.2.3. クラスを避けるべきケース
以下のような場合は、関数ベースのアプローチを採用する：

- **シングルトンやユーティリティ関数の実装**
  - ❌ 悪い例: 静的メソッドのみを持つクラス、またはシングルトンインスタンス
  ```typescript
  // 非推奨: クラスを使ったシングルトン
  class Logger {
    private config: LoggerConfig;
    constructor() { /* ... */ }
    debug(context: string, message: string): void { /* ... */ }
  }
  export const logger = new Logger();
  ```
  
  - ✅ 良い例: モジュールスコープの変数と関数ベースのアプローチ
  ```typescript
  // 推奨: 関数ベースのアプローチ
  let config: LoggerConfig = { /* ... */ };
  
  function log(level: LogLevel, context: string, message: string): void {
    /* ... */
  }
  
  export const logger = {
    debug: (context: string, message: string) => log(LogLevel.DEBUG, context, message),
    info: (context: string, message: string) => log(LogLevel.INFO, context, message),
  };
  ```

- **名前空間としての使用**
  - ❌ 悪い例: 静的メソッドのみを格納するためのクラス
  ```typescript
  // 非推奨
  class Utils {
    static formatDate(date: Date): string { /* ... */ }
    static parseJson(str: string): unknown { /* ... */ }
  }
  ```
  
  - ✅ 良い例: モジュールとして関数を直接エクスポート
  ```typescript
  // 推奨
  export function formatDate(date: Date): string { /* ... */ }
  export function parseJson(str: string): unknown { /* ... */ }
  ```

#### 2.2.4. 関数ベースアプローチの利点
- **軽量**: クラスのオーバーヘッドがない
- **Tree-shaking最適化**: 未使用の関数がより効率的に削除される可能性がある
- **モジュールパターンとの親和性**: ES Modulesの機能を最大限活用できる
- **関数型プログラミングスタイル**: TypeScript/JavaScriptのベストプラクティスに沿う

### 2.3. Enumの使用方針

#### 2.3.1. 基本方針
**TypeScriptにおけるenumの使用は推奨されない。**
enumには型安全性の問題があり、特に数値enumでは未定義の数値が代入可能になってしまう。代わりに`const object + union type`パターンを使用する。

#### 2.3.2. Enumの問題点
- **数値enumの型安全性の問題**: 数値enumでは、定義されていない数値を直接代入できてしまう
  ```typescript
  // 問題のある例
  enum LogLevel {
    DEBUG = 0,
    INFO = 1,
  }
  const level: LogLevel = 999; // エラーにならない！
  ```
- **文字列enumの問題**: 文字列enumも同様に、型安全性が完全ではない
- **JavaScriptへの変換**: enumはJavaScriptに変換される際に余分なコードが生成される

#### 2.3.3. 推奨される代替パターン
定数の集合を表現する場合は、`const object + union type`パターンを使用する：

- ❌ 悪い例: enumの使用
  ```typescript
  // 非推奨: enum
  export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
  }
  ```

- ✅ 良い例: const object + union type
  ```typescript
  // 推奨: const object + union type
  export const LogLevel = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
  } as const;

  export type LogLevel = typeof LogLevel[keyof typeof LogLevel];
  ```

このパターンの利点：
- **型安全性**: 定義された値のみが代入可能
- **数値比較の維持**: 数値としての比較（`<`, `>`, `<=`, `>=`）も可能
- **既存コードとの互換性**: `LogLevel.DEBUG`のような参照はそのまま動作
- **Tree-shaking最適化**: 未使用の値がより効率的に削除される可能性がある

## 3. コードスタイル

### 3.1. フォーマット
- コードをクリーンかつ一貫性のある状態に保つ
- 自動フォーマッター（Prettier等）を使用する場合は、プロジェクト全体で統一する

### 3.2. 命名規則
- **変数・関数**: `camelCase`を使用
- **型・インターフェース**: `PascalCase`を使用
- **定数**: `UPPER_SNAKE_CASE`を使用
- **プライベート変数・関数**: モジュールスコープでは命名規則で明確化（プレフィックスは使用しない）

### 3.3. コメント
- **公開API**: エクスポートされる関数や型には、使用方法を明記したJSDocコメントを追加する
- **実装意図**: 「What」ではなく「Why」を説明するコメントを追加する
- **説明用コメント禁止**: 実装の修正を行った際に修正内容について説明するようなコメントは入れないこと

### 3.4. ファイルサイズ
- **1ファイル200行以内を目安とする**: ファイルが長くなりすぎると、可読性と保守性が低下するため、1ファイルあたり200行以内を目安とする
- **200行を超える場合は分割を検討**: 200行を超えるファイルは、以下の観点から分割を検討する
  - **責務の分離**: 異なる責務を持つ機能は別ファイルに分離する
  - **関心の分離**: 型定義、状態管理、ストレージ操作、公開APIなど、関心ごとに分離する
  - **再利用性**: 他のモジュールから独立して使用できる単位で分割する
- **分割の例**:
  - 型定義とデフォルト値 → `*-types.ts`
  - 状態管理とマージ処理 → `*-state.ts`
  - ストレージ操作とイベント監視 → `*-storage.ts`
  - 公開API → メインファイル（`*.ts`）